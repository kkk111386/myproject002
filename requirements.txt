# app.py
# ì£¼ë¯¼ë“±ë¡ ì¸êµ¬ ë° ì„¸ëŒ€ í˜„í™© ì‹œê°í™” (Plotly + Streamlit ì•ˆì • ë²„ì „)

import streamlit as st
import pandas as pd
import os
import sys
import subprocess
from datetime import datetime

# âœ… Plotlyê°€ ì—†ì„ ê²½ìš° ìžë™ ì„¤ì¹˜
try:
    import plotly.express as px
except ModuleNotFoundError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "plotly"])
    import plotly.express as px

# ì•± ì„¤ì •
st.set_page_config(page_title="ì£¼ë¯¼ë“±ë¡ ì¸êµ¬ ì‹œê°í™”", layout="wide")

st.title("ðŸ“Š ì£¼ë¯¼ë“±ë¡ ì¸êµ¬ ë° ì„¸ëŒ€ í˜„í™© ì‹œê°í™” (Plotly ë²„ì „)")

# íŒŒì¼ ì—…ë¡œë“œ ë˜ëŠ” ê¸°ë³¸ ê²½ë¡œ ì‚¬ìš©
uploaded_file = st.file_uploader("CSV íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”", type=["csv"])
default_path = "202509_202509_ì£¼ë¯¼ë“±ë¡ì¸êµ¬ë°ì„¸ëŒ€í˜„í™©_ì›”ê°„ (1).csv"

if uploaded_file is not None:
    path = uploaded_file
else:
    if os.path.exists(default_path):
        path = default_path
    else:
        st.info("CSV íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜, ê¸°ë³¸ íŒŒì¼ì´ ê²½ë¡œì— ì¡´ìž¬í•´ì•¼ í•©ë‹ˆë‹¤.")
        st.stop()

# ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
@st.cache_data
def load_data(file):
    for enc in ("utf-8-sig", "cp949", "euc-kr", "utf-8"):
        try:
            df = pd.read_csv(file, encoding=enc)
            return df
        except Exception:
            continue
    raise ValueError("CSV íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¸ì½”ë”© ë˜ëŠ” íŒŒì¼ ë‚´ìš©ì„ í™•ì¸í•˜ì„¸ìš”.")

try:
    df = load_data(path)
except Exception as e:
    st.error(f"íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")
    st.stop()

st.success("âœ… ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ!")
st.write(f"ë°ì´í„° í–‰ ìˆ˜: {len(df):,}")

# ì»¬ëŸ¼ ì „ì²˜ë¦¬
df.columns = [c.strip() for c in df.columns]

# ê¸°ê°„ ì»¬ëŸ¼ íƒìƒ‰
period_col = next((c for c in df.columns if any(k in c for k in ["ê¸°ê°„", "ì—°ì›”", "ê¸°ì¤€ë…„ì›”"])), None)
if period_col:
    df["ê¸°ê°„"] = pd.to_datetime(df[period_col].astype(str).str[:6], format="%Y%m", errors="coerce")
else:
    df["ê¸°ê°„"] = pd.NaT

# ì£¼ìš” ì»¬ëŸ¼ ì¶”ì •
def find_col(keyword_list):
    for k in keyword_list:
        for c in df.columns:
            if k in c:
                return c
    return None

sido_col = find_col(["ì‹œë„"])
gungu_col = find_col(["ì‹œêµ°êµ¬", "êµ¬"])
sex_col = find_col(["ì„±ë³„"])
age_col = find_col(["ì—°ë ¹", "ë‚˜ì´"])
pop_col = find_col(["ì¸êµ¬"])
house_col = find_col(["ì„¸ëŒ€"])

# ðŸ”¹ ì‚¬ì´ë“œë°” í•„í„°
st.sidebar.header("í•„í„°")

if sido_col:
    sido_vals = sorted(df[sido_col].dropna().unique())
    sido_sel = st.sidebar.multiselect("ì‹œë„ ì„ íƒ", sido_vals, default=sido_vals[:3])
else:
    sido_sel = []

if gungu_col:
    if sido_sel:
        gungu_vals = sorted(df[df[sido_col].isin(sido_sel)][gungu_col].dropna().unique())
    else:
        gungu_vals = sorted(df[gungu_col].dropna().unique())
    gungu_sel = st.sidebar.multiselect("ì‹œêµ°êµ¬ ì„ íƒ", gungu_vals)
else:
    gungu_sel = []

if sex_col:
    sex_vals = sorted(df[sex_col].dropna().unique())
    sex_sel = st.sidebar.multiselect("ì„±ë³„ ì„ íƒ", sex_vals, default=sex_vals)
else:
    sex_sel = []

if df["ê¸°ê°„"].notna().any():
    min_date, max_date = df["ê¸°ê°„"].min(), df["ê¸°ê°„"].max()
    date_range = st.sidebar.date_input("ê¸°ê°„ ì„ íƒ", (min_date.date(), max_date.date()))
else:
    date_range = None

# ðŸ”¹ í•„í„° ì ìš©
mask = pd.Series(True, index=df.index)
if sido_col and sido_sel:
    mask &= df[sido_col].isin(sido_sel)
if gungu_col and gungu_sel:
    mask &= df[gungu_col].isin(gungu_sel)
if sex_col and sex_sel:
    mask &= df[sex_col].isin(sex_sel)
if date_range:
    start, end = date_range
    mask &= (df["ê¸°ê°„"] >= pd.to_datetime(start)) & (df["ê¸°ê°„"] <= pd.to_datetime(end))

df_f = df[mask].copy()

# ðŸ”¹ ìš”ì•½
st.subheader("ìš”ì•½ ì •ë³´")
if pop_col:
    total_pop = pd.to_numeric(df_f[pop_col], errors="coerce").sum()
    st.metric("ì´ ì¸êµ¬ìˆ˜", f"{int(total_pop):,}")
if house_col:
    total_house = pd.to_numeric(df_f[house_col], errors="coerce").sum()
    st.metric("ì´ ì„¸ëŒ€ìˆ˜", f"{int(total_house):,}")

# ðŸ”¹ Plotly ê·¸ëž˜í”„
if pop_col and df_f["ê¸°ê°„"].notna().any():
    st.subheader("ðŸ“ˆ ì¸êµ¬ ì‹œê³„ì—´ ì¶”ì´")
    ts = df_f.groupby("ê¸°ê°„")[pop_col].apply(lambda s: pd.to_numeric(s, errors="coerce").sum()).reset_index()
    fig = px.line(ts, x="ê¸°ê°„", y=pop_col, title="ê¸°ê°„ë³„ ì¸êµ¬ ë³€í™”", markers=True)
    fig.update_layout(template="plotly_white")
    st.plotly_chart(fig, use_container_width=True)

if age_col and pop_col and sex_col:
    st.subheader("ðŸ‘¥ ì—°ë ¹ëŒ€ ë° ì„±ë³„ ë¶„í¬")
    agg = df_f.groupby([age_col, sex_col])[pop_col].apply(lambda s: pd.to_numeric(s, errors="coerce").sum()).reset_index()
    fig = px.bar(agg, x=age_col, y=pop_col, color=sex_col, barmode="group", title="ì—°ë ¹ëŒ€ë³„ ì„±ë³„ ì¸êµ¬ ë¶„í¬")
    fig.update_layout(template="plotly_white")
    st.plotly_chart(fig, use_container_width=True)

if sido_col and pop_col:
    st.subheader("ðŸ™ï¸ ì‹œë„ë³„ ì¸êµ¬ìˆ˜ ìƒìœ„ 20")
    rank = df_f.groupby(sido_col)[pop_col].apply(lambda s: pd.to_numeric(s, errors="coerce").sum()).reset_index()
    rank = rank.sort_values(by=pop_col, ascending=False).head(20)
    fig = px.bar(rank, x=sido_col, y=pop_col, title="ì‹œë„ë³„ ì¸êµ¬ìˆ˜ TOP 20", color=pop_col)
    fig.update_layout(template="plotly_white")
    st.plotly_chart(fig, use_container_width=True)

# ë‹¤ìš´ë¡œë“œ
st.download_button("ðŸ“¥ í•„í„°ëœ ë°ì´í„° CSV ë‹¤ìš´ë¡œë“œ", df_f.to_csv(index=False).encode("utf-8-sig"),
                   file_name="filtered_population.csv", mime="text/csv")

st.sidebar.markdown("---")
st.sidebar.info("Plotly ê¸°ë°˜ ì¸í„°ëž™í‹°ë¸Œ ëŒ€ì‹œë³´ë“œ. ì§€ë„ ì‹œê°í™”ë„ ì¶”ê°€í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.")
